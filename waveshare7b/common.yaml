# common.yaml - Sensors, Scripts, Global Variables
# Screen-saver dims backlight after 5 min idle, touch wakes (handled in device.yaml)

time:
  - platform: homeassistant
    id: ha_time

globals:
  - id: entered_code
    type: std::string
    initial_value: '""'

  - id: pending_action
    type: std::string
    initial_value: '""'

  # Tracks seconds since last touch for screen-saver
  - id: idle_seconds
    type: int
    initial_value: '0'

# Screen saver - pause LVGL and dim backlight after 5 minutes of inactivity
# Touch screen to wake (handled by touchscreen on_touch in device.yaml).
interval:
  - interval: 1s
    then:
      - lambda: |-
          id(idle_seconds) += 1;
      - if:
          condition:
            lambda: 'return id(idle_seconds) >= 300;'
          then:
            - lambda: 'id(idle_seconds) = 0;'
            - lvgl.pause:
            - light.turn_off: display_backlight

sensor:
  - platform: wifi_signal
    name: "WiFi Signal"
    id: wifi_signal_strength
    update_interval: 60s
    internal: true

  - platform: homeassistant
    id: outside_temp_sensor
    entity_id: ${outside_temp}
    internal: true
    on_value:
      - lambda: |-
          char buf[10]; snprintf(buf, sizeof(buf), "%.0f°F", x);
          lv_label_set_text(id(outside_temp_main), buf);

  - platform: homeassistant
    id: alarm_delay_time
    entity_id: ${alarm_panel}
    attribute: delay
    internal: true

  - platform: homeassistant
    id: inside_temp_sensor
    entity_id: ${inside_temp}
    internal: true
    on_value:
      - lambda: |-
          char buf[10]; snprintf(buf, sizeof(buf), "%.0f°F", x);
          lv_label_set_text(id(inside_temp_main), buf);

  # Weather forecast high temps (from HA template sensors - see README)
  - platform: homeassistant
    id: forecast_high_0
    entity_id: sensor.weather_forecast_high_0
    internal: true
    on_value:
      - lambda: |-
          char buf[8]; snprintf(buf, sizeof(buf), "%.0f°", x);
          lv_label_set_text(id(wx_high_0), buf);
  - platform: homeassistant
    id: forecast_high_1
    entity_id: sensor.weather_forecast_high_1
    internal: true
    on_value:
      - lambda: |-
          char buf[8]; snprintf(buf, sizeof(buf), "%.0f°", x);
          lv_label_set_text(id(wx_high_1), buf);
  - platform: homeassistant
    id: forecast_high_2
    entity_id: sensor.weather_forecast_high_2
    internal: true
    on_value:
      - lambda: |-
          char buf[8]; snprintf(buf, sizeof(buf), "%.0f°", x);
          lv_label_set_text(id(wx_high_2), buf);
  - platform: homeassistant
    id: forecast_high_3
    entity_id: sensor.weather_forecast_high_3
    internal: true
    on_value:
      - lambda: |-
          char buf[8]; snprintf(buf, sizeof(buf), "%.0f°", x);
          lv_label_set_text(id(wx_high_3), buf);
  - platform: homeassistant
    id: forecast_high_4
    entity_id: sensor.weather_forecast_high_4
    internal: true
    on_value:
      - lambda: |-
          char buf[8]; snprintf(buf, sizeof(buf), "%.0f°", x);
          lv_label_set_text(id(wx_high_4), buf);

  # Weather forecast low temps
  - platform: homeassistant
    id: forecast_low_0
    entity_id: sensor.weather_forecast_low_0
    internal: true
    on_value:
      - lambda: |-
          char buf[8]; snprintf(buf, sizeof(buf), "%.0f°", x);
          lv_label_set_text(id(wx_low_0), buf);
  - platform: homeassistant
    id: forecast_low_1
    entity_id: sensor.weather_forecast_low_1
    internal: true
    on_value:
      - lambda: |-
          char buf[8]; snprintf(buf, sizeof(buf), "%.0f°", x);
          lv_label_set_text(id(wx_low_1), buf);
  - platform: homeassistant
    id: forecast_low_2
    entity_id: sensor.weather_forecast_low_2
    internal: true
    on_value:
      - lambda: |-
          char buf[8]; snprintf(buf, sizeof(buf), "%.0f°", x);
          lv_label_set_text(id(wx_low_2), buf);
  - platform: homeassistant
    id: forecast_low_3
    entity_id: sensor.weather_forecast_low_3
    internal: true
    on_value:
      - lambda: |-
          char buf[8]; snprintf(buf, sizeof(buf), "%.0f°", x);
          lv_label_set_text(id(wx_low_3), buf);
  - platform: homeassistant
    id: forecast_low_4
    entity_id: sensor.weather_forecast_low_4
    internal: true
    on_value:
      - lambda: |-
          char buf[8]; snprintf(buf, sizeof(buf), "%.0f°", x);
          lv_label_set_text(id(wx_low_4), buf);

text_sensor:
  - platform: homeassistant
    id: alarm_state
    entity_id: ${alarm_panel}
    internal: true
    on_value:
      - lambda: |-
          lv_color_t green  = lv_color_hex(0x30D158);
          lv_color_t gray   = lv_color_hex(0x8E8E93);
          lv_color_t orange = lv_color_hex(0xFF9F0A);
          lv_color_t red    = lv_color_hex(0xFF453A);
          const char* label = "Unknown";
          lv_color_t color = gray;
          if (x == "disarmed") { label = "DISARMED"; color = gray; }
          else if (x == "armed_away") { label = "ARMED AWAY"; color = green; }
          else if (x == "armed_home") { label = "ARMED HOME"; color = green; }
          else if (x == "armed_night") { label = "ARMED NIGHT"; color = green; }
          else if (x == "armed_vacation") { label = "ARMED VACATION"; color = green; }
          else if (x == "armed_custom_bypass") { label = "ARMED CUSTOM"; color = green; }
          else if (x == "pending") { label = "ARMING..."; color = orange; }
          else if (x == "triggered") { label = "TRIGGERED!"; color = red; }
          lv_label_set_text(id(alarm_status_main), label);
          lv_obj_set_style_text_color(id(alarm_status_main), color, 0);
          lv_label_set_text(id(alarm_status_detail), label);
          lv_obj_set_style_text_color(id(alarm_status_detail), color, 0);
          // Clear countdown if not pending
          if (x != "pending") {
            lv_label_set_text(id(alarm_countdown_detail), "");
            lv_label_set_text(id(alarm_countdown_main), "");
          }
          // Toggle arm buttons vs big disarm button
          if (x == "disarmed") {
            lv_obj_clear_flag(id(arm_buttons_container), LV_OBJ_FLAG_HIDDEN);
            lv_obj_add_flag(id(disarm_big_button), LV_OBJ_FLAG_HIDDEN);
          } else {
            lv_obj_add_flag(id(arm_buttons_container), LV_OBJ_FLAG_HIDDEN);
            lv_obj_clear_flag(id(disarm_big_button), LV_OBJ_FLAG_HIDDEN);
          }

  # Weather forecast conditions (text sensors from HA templates)
  # Each contains the HA weather condition string (sunny, cloudy, rainy, etc.)
  - platform: homeassistant
    id: forecast_cond_0
    entity_id: sensor.weather_forecast_condition_0
    internal: true
    on_value:
      - lambda: |-
          // Map HA condition to MDI icon codepoint
          auto icon_for = [](const std::string &c) -> const char* {
            if (c == "sunny" || c == "clear-night") return "\U000F059D";
            if (c == "cloudy") return "\U000F0590";
            if (c == "partlycloudy") return "\U000F0595";
            if (c == "rainy") return "\U000F0597";
            if (c == "pouring") return "\U000F0596";
            if (c == "snowy") return "\U000F0598";
            if (c == "snowy-rainy") return "\U000F067F";
            if (c == "lightning") return "\U000F0593";
            if (c == "lightning-rainy") return "\U000F067E";
            if (c == "fog") return "\U000F0591";
            if (c == "hail") return "\U000F0592";
            if (c == "windy" || c == "windy-variant") return "\U000F059E";
            return "\U000F059D";
          };
          lv_label_set_text(id(wx_icon_0), icon_for(x));
  - platform: homeassistant
    id: forecast_cond_1
    entity_id: sensor.weather_forecast_condition_1
    internal: true
    on_value:
      - lambda: |-
          auto icon_for = [](const std::string &c) -> const char* {
            if (c == "sunny" || c == "clear-night") return "\U000F059D";
            if (c == "cloudy") return "\U000F0590";
            if (c == "partlycloudy") return "\U000F0595";
            if (c == "rainy") return "\U000F0597";
            if (c == "pouring") return "\U000F0596";
            if (c == "snowy") return "\U000F0598";
            if (c == "snowy-rainy") return "\U000F067F";
            if (c == "lightning") return "\U000F0593";
            if (c == "lightning-rainy") return "\U000F067E";
            if (c == "fog") return "\U000F0591";
            if (c == "hail") return "\U000F0592";
            if (c == "windy" || c == "windy-variant") return "\U000F059E";
            return "\U000F059D";
          };
          lv_label_set_text(id(wx_icon_1), icon_for(x));
  - platform: homeassistant
    id: forecast_cond_2
    entity_id: sensor.weather_forecast_condition_2
    internal: true
    on_value:
      - lambda: |-
          auto icon_for = [](const std::string &c) -> const char* {
            if (c == "sunny" || c == "clear-night") return "\U000F059D";
            if (c == "cloudy") return "\U000F0590";
            if (c == "partlycloudy") return "\U000F0595";
            if (c == "rainy") return "\U000F0597";
            if (c == "pouring") return "\U000F0596";
            if (c == "snowy") return "\U000F0598";
            if (c == "snowy-rainy") return "\U000F067F";
            if (c == "lightning") return "\U000F0593";
            if (c == "lightning-rainy") return "\U000F067E";
            if (c == "fog") return "\U000F0591";
            if (c == "hail") return "\U000F0592";
            if (c == "windy" || c == "windy-variant") return "\U000F059E";
            return "\U000F059D";
          };
          lv_label_set_text(id(wx_icon_2), icon_for(x));
  - platform: homeassistant
    id: forecast_cond_3
    entity_id: sensor.weather_forecast_condition_3
    internal: true
    on_value:
      - lambda: |-
          auto icon_for = [](const std::string &c) -> const char* {
            if (c == "sunny" || c == "clear-night") return "\U000F059D";
            if (c == "cloudy") return "\U000F0590";
            if (c == "partlycloudy") return "\U000F0595";
            if (c == "rainy") return "\U000F0597";
            if (c == "pouring") return "\U000F0596";
            if (c == "snowy") return "\U000F0598";
            if (c == "snowy-rainy") return "\U000F067F";
            if (c == "lightning") return "\U000F0593";
            if (c == "lightning-rainy") return "\U000F067E";
            if (c == "fog") return "\U000F0591";
            if (c == "hail") return "\U000F0592";
            if (c == "windy" || c == "windy-variant") return "\U000F059E";
            return "\U000F059D";
          };
          lv_label_set_text(id(wx_icon_3), icon_for(x));
  - platform: homeassistant
    id: forecast_cond_4
    entity_id: sensor.weather_forecast_condition_4
    internal: true
    on_value:
      - lambda: |-
          auto icon_for = [](const std::string &c) -> const char* {
            if (c == "sunny" || c == "clear-night") return "\U000F059D";
            if (c == "cloudy") return "\U000F0590";
            if (c == "partlycloudy") return "\U000F0595";
            if (c == "rainy") return "\U000F0597";
            if (c == "pouring") return "\U000F0596";
            if (c == "snowy") return "\U000F0598";
            if (c == "snowy-rainy") return "\U000F067F";
            if (c == "lightning") return "\U000F0593";
            if (c == "lightning-rainy") return "\U000F067E";
            if (c == "fog") return "\U000F0591";
            if (c == "hail") return "\U000F0592";
            if (c == "windy" || c == "windy-variant") return "\U000F059E";
            return "\U000F059D";
          };
          lv_label_set_text(id(wx_icon_4), icon_for(x));

  # Forecast day names (e.g., "Mon", "Tue", etc.)
  - platform: homeassistant
    id: forecast_day_0
    entity_id: sensor.weather_forecast_day_0
    internal: true
    on_value:
      - lambda: lv_label_set_text(id(wx_day_0), x.c_str());
  - platform: homeassistant
    id: forecast_day_1
    entity_id: sensor.weather_forecast_day_1
    internal: true
    on_value:
      - lambda: lv_label_set_text(id(wx_day_1), x.c_str());
  - platform: homeassistant
    id: forecast_day_2
    entity_id: sensor.weather_forecast_day_2
    internal: true
    on_value:
      - lambda: lv_label_set_text(id(wx_day_2), x.c_str());
  - platform: homeassistant
    id: forecast_day_3
    entity_id: sensor.weather_forecast_day_3
    internal: true
    on_value:
      - lambda: lv_label_set_text(id(wx_day_3), x.c_str());
  - platform: homeassistant
    id: forecast_day_4
    entity_id: sensor.weather_forecast_day_4
    internal: true
    on_value:
      - lambda: lv_label_set_text(id(wx_day_4), x.c_str());

  # Lock entities (lock.* states are 'locked'/'unlocked', not binary)
  - platform: homeassistant
    id: front_door_locked
    entity_id: ${front_door_lock}
    internal: true
    on_value:
      - lambda: |-
          std::string s = x;
          for (auto &ch : s) ch = tolower(ch);
          bool locked = (s == "locked");
          lv_color_t c = locked ? lv_color_hex(0x30D158) : lv_color_hex(0xFF453A);
          const char* t = locked ? "Locked" : "Unlocked";
          const char* icon = locked ? "\U000F033E" : "\U000F033F";
          ESP_LOGI("lock", "Front door state raw: '%s' lower: '%s' locked=%d", x.c_str(), s.c_str(), locked);
          lv_label_set_text(id(front_door_main), t);
          lv_obj_set_style_text_color(id(front_door_main), c, 0);
          lv_label_set_text(id(front_door_icon_main), icon);
          lv_obj_set_style_text_color(id(front_door_icon_main), c, 0);
          lv_label_set_text(id(front_door_status_locks), t);
          lv_obj_set_style_text_color(id(front_door_status_locks), c, 0);
          lv_label_set_text(id(front_door_icon_locks), icon);
          lv_obj_set_style_text_color(id(front_door_icon_locks), c, 0);
      - script.execute: update_security_status

  - platform: homeassistant
    id: back_door_locked
    entity_id: ${back_door_lock}
    internal: true
    on_value:
      - lambda: |-
          std::string s = x;
          for (auto &ch : s) ch = tolower(ch);
          bool locked = (s == "locked");
          lv_color_t c = locked ? lv_color_hex(0x30D158) : lv_color_hex(0xFF453A);
          const char* t = locked ? "Locked" : "Unlocked";
          const char* icon = locked ? "\U000F033E" : "\U000F033F";
          ESP_LOGI("lock", "Back door state raw: '%s' lower: '%s' locked=%d", x.c_str(), s.c_str(), locked);
          lv_label_set_text(id(back_door_main), t);
          lv_obj_set_style_text_color(id(back_door_main), c, 0);
          lv_label_set_text(id(back_door_icon_main), icon);
          lv_obj_set_style_text_color(id(back_door_icon_main), c, 0);
          lv_label_set_text(id(back_door_status_locks), t);
          lv_obj_set_style_text_color(id(back_door_status_locks), c, 0);
          lv_label_set_text(id(back_door_icon_locks), icon);
          lv_obj_set_style_text_color(id(back_door_icon_locks), c, 0);
      - script.execute: update_security_status

  # Garage cover entity (cover.* states are 'open'/'closed', not binary)
  - platform: homeassistant
    id: garage_door_open
    entity_id: ${south_garage_sensor}
    internal: true
    on_value:
      - lambda: |-
          std::string s = x;
          for (auto &ch : s) ch = tolower(ch);
          bool is_open = (s == "open" || s == "opening" || s == "on");
          const char* icon = is_open ? "\U000F12D4" : "\U000F12D3";
          lv_color_t c = is_open ? lv_color_hex(0xFF9F0A) : lv_color_hex(0x30D158);
          const char* t = is_open ? "Open" : "Closed";
          ESP_LOGI("garage", "S.Garage state raw: '%s' lower: '%s' open=%d", x.c_str(), s.c_str(), is_open);
          lv_label_set_text(id(garage_icon_main), icon);
          lv_obj_set_style_text_color(id(garage_icon_main), c, 0);
          lv_label_set_text(id(garage_status_main), t);
          lv_obj_set_style_text_color(id(garage_status_main), c, 0);
          lv_label_set_text(id(garage_icon_locks), icon);
          lv_obj_set_style_text_color(id(garage_icon_locks), c, 0);
          lv_label_set_text(id(garage_status_locks), t);
          lv_obj_set_style_text_color(id(garage_status_locks), c, 0);
          lv_label_set_text(id(garage_quick_icon), icon);
          lv_obj_set_style_text_color(id(garage_quick_icon), c, 0);
      - script.execute: update_security_status

binary_sensor:
  # Light entities
  - platform: homeassistant
    id: living_room_light_state
    entity_id: ${living_room_light}
    internal: true
    on_state:
      - lambda: |-
          lv_color_t c = x ? lv_color_hex(0xFFD700) : lv_color_hex(0x8E8E93);
          const char* t = x ? "ON" : "OFF";
          lv_label_set_text(id(living_room_toggle_text), t);
          lv_obj_set_style_text_color(id(living_room_toggle_text), c, 0);
          lv_obj_set_style_text_color(id(living_room_light_icon), c, 0);

  # Lock & S.Garage entities moved to text_sensor section above

  # Garage entities (north)
  - platform: homeassistant
    id: north_garage_door_open
    entity_id: ${north_garage_sensor}
    internal: true
    on_state:
      - lambda: |-
          const char* icon = x ? "\U000F12D4" : "\U000F12D3";
          lv_color_t c = x ? lv_color_hex(0xFF9F0A) : lv_color_hex(0x30D158);
          const char* t = x ? "Open" : "Closed";
          lv_label_set_text(id(north_garage_icon_main), icon);
          lv_obj_set_style_text_color(id(north_garage_icon_main), c, 0);
          lv_label_set_text(id(north_garage_status_main), t);
          lv_obj_set_style_text_color(id(north_garage_status_main), c, 0);
      - script.execute: update_security_status

  - platform: homeassistant
    id: back_door_sensor_open
    entity_id: ${back_door_sensor}
    internal: true
    on_state:
      - lambda: |-
          lv_label_set_text(id(back_door_sensor_status), x ? "Door OPEN" : "Door Closed");
          lv_obj_set_style_text_color(id(back_door_sensor_status), x ? lv_color_hex(0xFF453A) : lv_color_hex(0x8E8E93), 0);
      - script.execute: update_security_status

  - platform: homeassistant
    id: front_door_sensor_open
    entity_id: ${front_door_sensor}
    internal: true
    on_state:
      - lambda: |-
          lv_label_set_text(id(front_door_sensor_status), x ? "Door OPEN" : "Door Closed");
          lv_obj_set_style_text_color(id(front_door_sensor_status), x ? lv_color_hex(0xFF453A) : lv_color_hex(0x8E8E93), 0);

  # Back door lock
  # (moved to text_sensor section above — lock.* entities need string comparison)

  - platform: homeassistant
    id: kitchen_light_state
    entity_id: ${kitchen_light}
    internal: true
    on_state:
      - lambda: |-
          lv_color_t c = x ? lv_color_hex(0xFFD700) : lv_color_hex(0x8E8E93);
          lv_label_set_text(id(kitchen_toggle_text), x ? "ON" : "OFF");
          lv_obj_set_style_text_color(id(kitchen_toggle_text), c, 0);
          lv_obj_set_style_text_color(id(kitchen_light_icon), c, 0);

  - platform: homeassistant
    id: outdoor_light_state
    entity_id: ${outdoor_light}
    internal: true
    on_state:
      - lambda: |-
          lv_color_t c = x ? lv_color_hex(0xFFD700) : lv_color_hex(0x8E8E93);
          lv_label_set_text(id(outdoor_toggle_text), x ? "ON" : "OFF");
          lv_obj_set_style_text_color(id(outdoor_toggle_text), c, 0);
          lv_obj_set_style_text_color(id(outdoor_light_icon), c, 0);

script:
  # Shared security status recalculation (called by lock/door/garage sensor callbacks)
  - id: update_security_status
    then:
      - lambda: |-
          lv_color_t green = lv_color_hex(0x30D158);
          lv_color_t red   = lv_color_hex(0xFF453A);
          bool has_open = false;
          std::string list = "";
          std::string gs = id(garage_door_open).state; for (auto &ch : gs) ch = tolower(ch);
          bool s_garage_open = (gs == "open" || gs == "opening" || gs == "on");
          if (id(garage_door_open).has_state() && s_garage_open) { has_open = true; list += "S.Garage  "; }
          if (id(north_garage_door_open).has_state() && id(north_garage_door_open).state) { has_open = true; list += "N.Garage  "; }
          if (id(back_door_sensor_open).has_state() && id(back_door_sensor_open).state) { has_open = true; list += "Back Door  "; }
          std::string fl = id(front_door_locked).state; for (auto &ch : fl) ch = tolower(ch);
          std::string bl = id(back_door_locked).state; for (auto &ch : bl) ch = tolower(ch);
          if (id(front_door_locked).has_state() && fl != "locked") { has_open = true; list += "Front Unlocked  "; }
          if (id(back_door_locked).has_state() && bl != "locked") { has_open = true; list += "Back Unlocked"; }
          if (has_open) {
            lv_obj_clear_flag(id(open_sensors_warning), LV_OBJ_FLAG_HIDDEN);
            lv_label_set_text(id(open_sensors_list), list.c_str());
          } else {
            lv_obj_add_flag(id(open_sensors_warning), LV_OBJ_FLAG_HIDDEN);
          }
          if (list.empty()) {
            lv_label_set_text(id(alarm_sensors_list), "All Secured");
            lv_obj_set_style_text_color(id(alarm_sensors_list), green, 0);
          } else {
            lv_label_set_text(id(alarm_sensors_list), list.c_str());
            lv_obj_set_style_text_color(id(alarm_sensors_list), red, 0);
          }
          bool any = false;
          if (id(front_door_locked).has_state() && fl != "locked") any = true;
          if (id(back_door_locked).has_state() && bl != "locked") any = true;
          if (id(garage_door_open).has_state() && s_garage_open) any = true;
          if (id(north_garage_door_open).has_state() && id(north_garage_door_open).state) any = true;
          lv_label_set_text(id(security_summary), any ? "Open / Unsecured" : "All Secured");
          lv_obj_set_style_text_color(id(security_summary), any ? red : green, 0);
          lv_label_set_text(id(security_summary_locks), any ? "Open / Unsecured" : "All Secured");
          lv_obj_set_style_text_color(id(security_summary_locks), any ? red : green, 0);

  - id: arm_away_script
    then:
      - homeassistant.service:
          service: alarm_control_panel.alarm_arm_away
          data:
            entity_id: ${alarm_panel}
            code: !lambda 'return id(entered_code);'

  - id: arm_home_script
    then:
      - homeassistant.service:
          service: alarm_control_panel.alarm_arm_home
          data:
            entity_id: ${alarm_panel}
            code: !lambda 'return id(entered_code);'

  - id: arm_night_script
    then:
      - homeassistant.service:
          service: alarm_control_panel.alarm_arm_night
          data:
            entity_id: ${alarm_panel}
            code: !lambda 'return id(entered_code);'

  - id: arm_vacation_script
    then:
      - homeassistant.service:
          service: alarm_control_panel.alarm_arm_vacation
          data:
            entity_id: ${alarm_panel}
            code: !lambda 'return id(entered_code);'

  - id: arm_custom_bypass_script
    then:
      - homeassistant.service:
          service: alarm_control_panel.alarm_arm_custom_bypass
          data:
            entity_id: ${alarm_panel}
            code: !lambda 'return id(entered_code);'

  - id: disarm_script
    then:
      - homeassistant.service:
          service: alarm_control_panel.alarm_disarm
          data:
            entity_id: ${alarm_panel}
            code: !lambda 'return id(entered_code);'
